\subsection{Obfuscating Transformations}

\input{tigress_options.tex}

In our experiments we use the Tigress C source-to-source obfuscator. Tigress supports a wide range of transformations, and each transformation has multiple options that controls how the obfuscated code is generated. Table~\ref{tab:tigress} shows the Tigress transformations, options, and range of option values that we used in our experiments.

\begin{figure*}
\begin{center}
\begin{minipage}{12cm}
\begin{lstlisting}[basicstyle=\footnotesize]
tigress --Seed=42 --Transform=InitOpaque --Functions=main \
   --Transform=Virtualize --Functions=foo --VirtualizeDispatch=direct \
   --Transform=AddOpaque --Functions=foo --AddOpaqueCount=20 --out=output.c input.c
\end{lstlisting}
\end{minipage}
\end{center}
\caption{Example Tigress invocation.}
\label{fig:tigresscall}
\end{figure*}

Figure~\ref{fig:tigresscall} shows a  call to Tigress to transform a C program {\tt input.c} into {\tt output.c}. This particular invocation first applies the {\tt Virtualize} transformation to the function named {\tt foo} using {\em direct} dispatch, and then adds 20 opaque predicates to the virtualized {\tt foo}. This is a very typical use of an obfuscator, applying multiple transformations to the same function, in order to protect against different types of attack. Note that a {\em seed} can be given to Tigress, which randomizes all internal decisions and allows multiple, differently obfuscated, programs to be generated from the same input program. This is used to generate a diverse set of programs, making it more difficult for an adversary to create generalized attack scripts that work across many obfuscated programs. 

\CC{AR and JP: are these numbers still correct?}
\JP{Dear sir, these are the exact numbers matching with our variants but not the same as before in aakarshs paper}

In our experiments, we do not combine transformations, but only apply one at a time to each of the benchmarks. For each transformation we run all possible  combinations of the values of all options shown in  Table~\ref{tab:tigress}. This results in 16 variant options for \emph{Virtualize}, 128 variant options for \emph{Merge}, 35 variant options for \emph{Split}, 75 variant options for \emph{Add Opaque}, 128 variant options for \emph{Flatten}, 1 variant option for \emph{Encode Arithmetic} and 3 variant options for \emph{Encode Literal}. 

We apply each transformation variant to all the functions in each benchmark. In practice, this is unrealistic; in most scenarios only security-sensitive functions are obfuscated to avoid too much overhead. For the MiBench benchmarks, however, it is unclear which part of the code should be considered ``security-sensitive,'' and we therefore transform the entire program.

\CC{AR and JP: fix this with the correct command and compiler, including compiler version.}
After the obfuscated programs have been generated they are compiled with optimization using the {\tt gcc} compiiler: {\tt gcc -O i.c ....}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Old stuff
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\endinput

\AR{Dr.Collberg: Can you add a short description of these options? Just stating it wouldn't make send to a reviewer. Else, how about having a table for this? Transformation | Options | Description}
\subsubsection{Virtualize}
Virtualize involves transforming a function into an interpretor, whose bytecode language is specialized for the particular function specified. 



\begin{itemize}
\item \textit{--VirtualizeDispatch=[direct,indirect and switch]}.
\item \textit{--VirtualizeSuperOpsRatio=[2 and 0]}.
\item \textit{--VirtualizeMaxMergeLength=[5 and 0]}.
\item \textit{--VirtualizePerformance=[AddressSizeShort, CacheTop and PointerStack]}.
\item \textit{--VirtualizeOperands=[stack and registers]}.
\end{itemize}


\subsubsection{AddOpaque}
Split up control flow by adding opaque branches.

\begin{itemize}
\item \textit{--AddOpaqueKinds=[bug and junk]}
\item \textit{--AddOpaqueCount=[1,5,10,15 and 20]}
\end{itemize}


\subsubsection{Encode Arithmetic}
Encode arithmetic replaces integer arithmetic expression with more complex expression. Tigress currently supports one option for this transformation.

\begin{itemize}
\item \textit{--EncodeArithmetic}.
\end{itemize}


\subsubsection{Encode Literal}
This technique obfuscates string and integer literals with less obvious expression. A single option of encoding integer and string is utilized.

\begin{itemize}
\item \textit{--EncodeLiterals=[Integer and String]}.
\end{itemize}

\subsubsection{Flatten}
Remove control flow from a function.

\begin{itemize}
\item \textit{--FlattenDispatch=[switch, goto and indirect]}.
\item \textit{--FlattenSplitBasicBlocks=[true and false]}.
\end{itemize}



\subsubsection{Merge}
This transformation technique merges multiple functions together into one. The following options are supported in Tigress: 

\begin{itemize}
\item \textit{--MergeFlatten=[true and false]}.
\item \textit{--MergeFlattenDispatch=[goto,indirect and switch]}.
\item Split \textit{--MergeSplitBasicBlocks=[true and false]}.
\item Randomize \textit{--MergeSplitBasicBlocks	=[true and false]}.
\end{itemize}


\subsubsection{Split}
Split transformation breaks a function into less conspicuous pieces that are their own functions. The option utilized for this transformation is an attempt at the number of times the splitting needs to be performed. 

\begin{itemize}
\item \textit{--SplitCount=[1,5,10 and 15]}.
\end{itemize}

