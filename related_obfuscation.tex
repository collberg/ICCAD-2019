\subsection{Code Obfuscation}
\begin{figure*}
\begin{lstlisting}[mathescape=false,language=C,basicstyle=\footnotesize,escapechar=@]
int main( ) { 
  char vars[32]; union node stack[32]; union node *sp; void **pc;
  void *bytecode[1][15] =
     &&local_load_const_xor, (void *)24UL, (void *)1UL,&&local_load_const_or_const,(void *)24UL, (void *)1UL, (void *)1UL, 
     &&shiftl_minus_local_store_const, (void *)24UL, (void *)0UL, &&local_store, (void *)28UL,  &&local_load, 
     (void *)28UL, &&return_int}};
   sp=stack; pc=bytecode; goto *(*pc);
   @\underline{\tt local\_store}@: pc++; *((int *)((void *)(vars+*((int *)pc))))=(sp+0)->_int; sp--; pc++; goto *(*pc);
   @\underline{\tt local\_load\_const\_or\_const}@: pc++; (sp+1)->_int=*((int *)((void *)(vars+*((int *)pc))))|*((int *)(pc+1));
         (sp+2)->_int=*((int *)(pc+2)); sp+=2; pc+=3; goto *(*pc);
   @\underline{\tt local\_load}@: pc++; (sp+1)->_int=*((int *)((void *)(vars+*((int *)pc)))); sp++; pc++; goto *(*pc);
   @\underline{\tt return\_int}@: pc++;  return ((sp+0)->_int); goto *(*pc);
   @\underline{\tt local\_load\_const\_xor}@: pc++; (sp+1)->_int=*((int *)((void *)(vars+*((int *)pc))))^*((int *)(pc+1)); sp++; pc+=2; goto *(*pc);
   @\underline{\tt shiftl\_minus\_local\_store\_const}@: pc++; (sp+-2)->_int=((sp+-1)->_int<<(sp+0)->_int)-(sp+-2)->_int;
     *((int *)((void *)(vars+*((int *)pc))))=(sp+-2)->_int; 
     (sp+-2)->_int=*((int *)(pc+1)); sp+=-2; pc+=2; goto *(*pc);
}
\end{lstlisting}
\caption{The program {\tt int main()\{int x++;\}} obfuscated by Tigress, using first the {\tt EncodeArithmetic} transformation (which turns {\tt x++} into {\tt x = ((x|1)<<1)-(x\^{}1))} followed by the {\tt Virtualize} transformation.}
\label{fig:virtualize}
\end{figure*}

Code obfuscation has been used to mitigate several different security problems. For example, it has been used to protect security checks in Digital Rights Management systems~\cite{horning05softwarea,chow02white-box}, to protect intellectual property in languages like Java~\cite{collberg1997taxonomy}, and to diversify malware to protect it from detection by virus scanners~\cite{Skulason92mutation}. 

Collberg and Nagra~\cite{collberg_surreptitious_2010} describe many obfuscating code transformations. Common transformations include {\em control flow flattening}~\cite{wang00security} which is used to remove control flow from a function,  {\em opaque predicate insertion} which adds fake control flow statements~\cite{collberg1997taxonomy}, and {\em virtualization}~\cite{yadegari15generic}. Virtualization is a particularly common transformation, employed by many commercial tools, such as CodeVirtualizer and Themida\footnote{\url{https://www.oreans.com}.}. Figure~\ref{fig:virtualize} shows the result of virtualizing the trivial program {\tt int main()\{int x++;\}}. The virtualized code consists of a {\em bytecode} array of randomly generated virtual instructions, an execution stack, and  an interpreter specialized to execute the generated bytecode. Typically, multiple transformations are composed to protect against different types of attack. For example, the code in Figure~\ref{fig:virtualize} is the result of the {\em Mixed Boolean Arithmetic}~\cite{Zhou:2007:IHS:1784964.1784971} transformation, followed by virtualization.